[
["index.html", "Язык R в интернет маркетинге 1 Описание", " Язык R в интернет маркетинге Алексей Селезнёв 2018-08-03 1 Описание Данная методичка представляет из себя краткий конспект курса “Язык R в интернет маркетинга”, и поможет студентам в поиске нужных материалов по завершению курса для решения своих повседневных задач. "],
["-1-r-.html", "2 Модуль 1: Введение в R. 2.1 История создания языка R 2.2 Преимущества языка R. 2.3 Установка языка R и среды разработки RStudio 2.4 Загрузка, преобразование и визуализация данных в Power BI с помощью R скриптов. 2.5 Среда разработки RStudio 2.6 Классы объектов в языке R 2.7 Работа со строками на языке R 2.8 Загрузка данных из csv, excel и json файлов в R 2.9 Агрегирующие функции и арифметические операции в R 2.10 Манипуляция с данными, (группировка и агреция). 2.11 Работа с датами и временем в R, пакет lubridate. 2.12 Условные конструкции if, ifelse, switch в R 2.13 Циклы for и while 2.14 Разработка собственных функций в языке R 2.15 Обработка ошибок в R, функция try 2.16 Рекомендации по оформлению кода", " 2 Модуль 1: Введение в R. Первый модуль курса посвящён введению в язык R, в ходе модуля рассматривается следующие темы: История, возможности, преимущества и недостатки языка R. Загрузка и установка языка R и среды разработки RStudio. Области применения R скриптов в Power BI. Знакомство со средой разработки RStudio. Основные классы объектов в R Векторы в R, что такое вектор, как обращаться к элементам вектора, основные типы данных в R. Data frame, основной класс объектов в R, как выбирать столбцы, строки, проводить расчёты. List - Списки. R пакеты. Как упростить и ускорить работу с таблицами с помощью пакета data.table. Манипуляция с данными с помощью пакета dplyr. Преобразование данных с помощью пакета tidyr. Циклы в R (for и while), синтаксис, пример использования. 2.1 История создания языка R Язык R был разработан в 1993 году сотрудниками статистического факультета Оклендского университета Россом Айхэкой (англ. Ross Ihaka) и Робертом Джентлменом (англ. Robert Gentleman) (первая буква их имён — R), для для статистической обработки данных и работы с графикой. Долгие годы R использовался исключительно в исследовательских институтах для статического анализа данных, в бизнес и маркетинг этот язык просочился уже ближе к 2010 году. Именно в 2010 году R вошёл в список победителей конкурса журнала Infoworld[en] в номинации на лучшее открытое программное обеспечение для разработки приложений. 2.2 Преимущества языка R. R является Свободным программным обеспечением. R — это очень общий пакет статистического анализа, включает длинный список функций и пакетов, написанных пользователями. Смотрите: CRAN Contributed packages(англ.). R доступен для всех операционных систем, включая Linux, Mac OS, Windows. R включает самые последние методики. R — объектно ориентированный. Теоретически, всё что угодно может быть сохранено как объект R. Для пользователей умеющих писать более не менее сложные формулы в Ecxel перейти в R будет первое время непривычно но не сложно. Язык R предоставляет пользователю практически неограниченные возможности для визуализации данных. Поскольку R является любимым языком профессиональных статистиков, все последние достижения статистической науки очень быстро становятся доступными для пользователей R во всем мире в виде дополнительных библиотек. Ни одна коммерческая система статистического анализа так быстро сегодня не развивается. 2.3 Установка языка R и среды разработки RStudio Процесс установки языка R и RStudio достаточно прост и не требует никаких дополнительных манипуляций, нет никакой необходимости менять какие либо настройки в мастере установки. 2.3.1 Ссылки для загрузки R и RStudio R для Windows - https://cran.r-project.org/bin/windows/base/ RStudio - https://www.rstudio.com/products/rstudio/download/ 2.4 Загрузка, преобразование и визуализация данных в Power BI с помощью R скриптов. 2.4.1 Загрузка данных в Power BI. Для загрузки данных с применением R скриптов перейдите в Power BI в диалоговое окно “Получить данные”, перейдите в группу “Другое”, выберите из доступных коннекторов “R-скрипт” и нажмите кнопку “Подключится”. Окно “Получить данные” в Power BI После чего попав в диалоговое окно “R-скрипт” введите следующий код для загрузки данных из csv файла, при использовании приведённого ниже кода необходимо прописать путь к файлу name_values.csv, там куда вы распаковали материали курса: # Загрузка таблицы данных my_data &lt;- read.table(file = &quot;C:/r_for_marketing_course/Материалы курса/Модуль 1/Урок 3/name_values.csv&quot;, sep = &quot;;&quot;, header = TRUE) Загрузка данных в Power BI Помните что обратный слеш (\\) в R используется для экранирования символов, поэтому при прописывании пути к файлу необходимо использовать либо прямой слэш (/), либо двойной обратный слэш (\\\\). 2.4.2 Преобразование данных в Power BI (power query). Задача: Необходимо обезличить данные, загруженные на прошлом шаге, в загруженной таблице есть 3 поля: ID, Name, Value, задача заключается в том, что бы заменить все имена на user_номер пользователя. Для решения задачи нам необходимо перейти в редактор запросов, далее перейти на вкладку “Преобразование”, и ажать кнопку “Запустить сценарий R”: Далее в окне “Запустить сценарий R” воспроизвести следующий код: # &#39;dataset&#39; содержит входные данные для этого сценария # Копируем входящие данные в дата фрейм my_data my_data &lt;- dataset # Создаём таблицу Id пользователей user_id &lt;- data.frame(Name = unique(my_data$Name), user_id = 1:length(unique(my_data$Name))) # Соединяем таблицу данных с таблицей Id пользователей my_data &lt;- merge(x = my_data, y = user_id, by = &quot;Name&quot;, all.x = TRUE) # Удаляем столбец с именами my_data$Name &lt;- NULL # Добавляем к id пользователя суфикс my_data$user_id &lt;- paste0(&quot;user_&quot;, my_data$user_id) # Удаляем таблицу id пользователей rm(user_id) 2.4.3 Визуализация данных в Power BI с помощью визуального элемента скрипта R. Среди доступных визуальных элементов в Power BI есть элемент который называется “Визуальный элемент скрипта R”. Выбирите данный визуальный элемент и перенестине в область значений все поля из загруженной на прошлом шаге таблице, т.е. поля Id, user_id и Value. Необходимо помнить о том, что дубли строк обрабатываемой данным визуальным элементом таблицы будут удалены, избежать этого можно с помощью индексированного столбца, в нашем случае таким столбцом является поле Id, для того, что бы не удалять из таблицы нужные нам строки необходимо убрать агрегацию по столбцу Id. Код для построения график ящик с усами: boxplot(data = dataset, Value ~ user_id) Запись Value ~ user_id является формулой, с левой стороны от тильды записывается количественная переменная (Value), с правой стороны качественная переменная (user_id), если вы сделали всё верно на трёх предыдущих шагах, загрузили, преобразовали и визуализировали данные из файла name_values.csv в Power BI вы должны получить получить следующий результат, в случае если у вас что либо не получилось можно посмотреть готовый результат в файле m1_l3 - demo name_values. Результат который вы должны получить в ходе выполнения 3го урока 2.4.4 Использование пользовательских параметров Power BI в R скриптах. В Power BI при загрузки и преобразования данных с помщью R скриптов есть возможность передавать значение созданных вами параметров, для этого сначала необходимо создать параметры, значения которых вы в дальнейшем будете использовать в R скриптах. Задача: Создать два параметра, с помощью первого параметра мы будем менять файл из которого загружаем данные, с помощью второго можно будет менять используемый ранее префикс “user_” на любой другой. Создать параметры можно перейдя в редактор запросов. Создание параметров в Power BI Создав два параметра file_name и prefix_name, Выбираем запрос my_data, внутри которого будем использовать созданные параметры и переходим в расширенный редактор запросов. Переход в расширенный редактор запросов В запросе my_data мы дважды используем сценарий R, первый раз для загрузки данных, второй раз для их преобразования, соответвенно первый созданный параметр file_name мы будем использовать в части скрипта которая отвечает за загрузку данных, а параметр prefix_name в части скрипта преобразующего данные. Поиск необходимой части скрипта загрузки и преобразования данных Для использования значений параметров внутри R скриптов достаточно с помощью функции Text.From языка M получить текстовое значение параметра и конкатенировать его в текст запроса с помощью символа &amp;. Пример конкатенации значения параметра в R скрипт 2.5 Среда разработки RStudio Среда разработки RStudio состоит из 4ёх диалоговы окон. Редактор скриптов, предназначени для разработки и отладки кода, работая в этом окне удобно запускать отдельные части кода, искать нужные части кода, в этом окне удобно работает дополнение кода. Консоль, в консоли выводятся все запускаемые вами команды и результат их выполнения включая сообщения об ошибках при их возникновении. Рабочее окружение, в данном диалоговом окне вы можете найти все объекты оторые были созданны вами в ходе R сессии, в зависимости от класса объекта вы так же можнтн либо перейти к его детальному просмотру, либо получить какую либо дополнительную информацию по любому из объектов. Справка и визуализация, в данном окне выводится вся запрашиваемая вами справочничная информаци, а так же визуализация данных внутри R. Важно: Вы можете в любой момент получить справку по любой функции языка R с помощью команды ?имя_функции. 2.6 Классы объектов в языке R В языке R существует достаточно много классов объектов, но как правило используется 3: Вектор, Дата фрейм и Список. 2.6.1 Векторы Вектор это объект содержащий набор элементов одного типа, вы не можете хранить в одном векторе элементы имеющие разный тип данных, например число и текст. 2.6.1.1 Создание вектора В R есть довольно много способов создания векторов, но наиболее простым и используемым является использование функции c. # создание тектового вектора names &lt;- c(&quot;Алексей&quot;, &quot;Денис&quot;, &quot;Николай&quot;, &quot;Виктор&quot;, &quot;Денис&quot;) country &lt;- c(&quot;RU&quot;, &quot;UA&quot;, &quot;KZ&quot;, &quot;BY&quot;, &quot;BG&quot;, &quot;BR&quot;, &quot;TR&quot;, &quot;US&quot;, &quot;CA&quot;) age &lt;- c(34, 25, 39, 30, 28) # создание числового вектора nums &lt;- 5:20 # создание вектора из простой последовательсти чисел nums &lt;- seq(from = 5, to = 20) nums_2 &lt;- seq(from = 5, to = 20, by = 2) # создание вектора из последовательности чисел с определённым шагом nums_3 &lt;- seq(from = 5, to = 20, length.out = 9) # создание последновательсти чисел определённой длинны # создание вектора с именоваными элементами name_vector &lt;- c(name = &quot;Алексей&quot;, age = 34, company = &quot;Netpeak&quot;) 2.6.1.2 Обращение к элементам вектора ПОлучить один или несколько конкретных элементов вектора можно несколькими способами, по индексу, явно указав какие элементы вам нужны с помозью TRUE / FALSE, задав логическое выражение для фильтрации элементов вектора либо по именам в случае если вектор имеет иненованые элементы. names[2] # значение по его индексу names[-4] # исключить значения по индексу names[c(2,4)] # нескоько значений по индексам names[c(TRUE, TRUE, FALSE, TRUE)] # с помощью логического TRUE / FALSE name_vector[&quot;company&quot;] # зачение по его имени age[ age &gt; 31 ] # через логическое выражение which(age &gt; 31) # получить индексы элементов по логическому выражению 2.6.1.3 Свойства вектора С помощью ряда функций вы можете получить свойства вектора, например такие как длинна, тип данных или имена элементов. class(nums_3) # получить тип данных class(age) length(names) # получить количество элементов names(name_vector) # получить имена элементов 2.6.1.4 Манипуляция с элементами вектора С элементами вектора можно проводить люые манипуляции, сортировать, делать случайные выборки элементов и объенять несколько векторов в один. sort(country) # сортировка элементов вектора по возрастанию sort(country, decreasing = TRUE) # сортировка элементов вектора по убыванию unique(names) # получить список уникальных элементов вектора sample(x = country, # выборка случайных элементов из вектора size = 8, replace = F) # replace управляет возможность повтора элементов c(age, nums) # объеденение двух векторов Функция sample позволяет получить набор случайных элементов из вектора, аргумент size отвечает за количество элементов которые вернёт функция, аргумент replace позволяет запретить отбирать один и тот же элемент вектора несколько раз. 2.6.1.5 Логические операция с элементами векторов Все операции сравнения над векторами зациклены, т.е. даже если вы будете сравнивать между собой элементы двух векторов разной длинны то в ходе сравнения элементов более длинного вектора начнут сравниваться с начальными элементами короткого вектора. vec1 &lt;- c(5, 8, 1, 9) vec2 &lt;- c(5, 2, 10) vec1 &gt; vec2 vec1 &gt; 3 &amp; vec1 &lt; 9 # пример логического и vec1 &lt; 8 | vec1 &gt; 8 # пример логического или Для более сложных операций сравнения в которы необходимо использовать логические операторы И и ИЛИ следует использовать одиночные знаки. &amp; - И | - ИЛИ 2.6.2 Таблицы (data.frame) Объекты касса data.frame являются привычными для вас двухмерными таблицами, по сути таблица это набор векторов одинаковой длинны, каждое поле таблицы может содержать данные только одного типа, так же как и вектора. 2.6.2.1 Создание таблицы Создавать таблицы можно с помощью функции data.frame, каждое поле таблицы является вектором и может содержать данные одного типа, все векторы из которых состоят поля таблицы должны быть одинаковой длинны. # Пример создание таблицы пользователей users &lt;- data.frame(Names = names, Age = age, Country_id = sample(1:length(country), size = length(names), replace = T), Id = 1:length(names)) # Создаём таблицу - справочник стран country_dicy &lt;- data.frame(id = 1:length(country), country_name = sort(country)) В приведённом примере мы создали две таблицы: users - таблица состоит из 4 полей (Names, Age, Country_id, Id). country_dicy - таблица состоит из двух полей (id, country_name). 2.6.2.2 Обращение к элементам таблицы Образаться к любым элементам таблицы, строкам или столбцам, можно либо по индексу либо по имени, для получения какого либо элемента необходимо написать название таблицы, открыть квадратные скобки и указать сначала строки и после запятой столбцы которые вам необходимо получить. users[3, ] # получить 3 строку users[2:4, ] # получить 2-4 строку по номеру users[, 2] # получить 2 столбец users[[&quot;Age&quot;]] # получить столбец по имени users$Age # получить столбец по имени users[, c(&quot;Names&quot;, &quot;Id&quot;)] # получить несколько столбцов по имени users[, c(2, 3)] # получить несколько столбцов по номерам users[ users$Age &gt; 30, ] # получить строки по логическому выражению users$Names[ users$Age &gt; 30 ] # получить значения одного поля, по лог выражению другого поля head(users, n = 3) # получить верхние 3 строки таблицы tail(users, n = 3) # получить нижние три строки таблицы 2.6.2.3 Просмотрт структуры и описательных статистик таблиц Просмотр структуры таблицы, т.е. информации о том какие поля есть в таблице, и данные какого типа в каком поле храняться можно с помощью функции str. str(users) # структура таблицы ## &#39;data.frame&#39;: 5 obs. of 4 variables: ## $ Names : Factor w/ 4 levels &quot;Алексей&quot;,&quot;Виктор&quot;,..: 1 3 4 2 3 ## $ Age : num 34 25 39 30 28 ## $ Country_id: int 8 8 4 9 4 ## $ Id : int 1 2 3 4 5 Получить описательные стаистики количественнх переменных и информацию о качественных переменных можно с помощью команды summary. summary(users) # описательные таблицы ## Names Age Country_id Id ## Алексей:1 Min. :25.0 Min. :4.0 Min. :1 ## Виктор :1 1st Qu.:28.0 1st Qu.:4.0 1st Qu.:2 ## Денис :2 Median :30.0 Median :8.0 Median :3 ## Николай:1 Mean :31.2 Mean :6.6 Mean :3 ## 3rd Qu.:34.0 3rd Qu.:8.0 3rd Qu.:4 ## Max. :39.0 Max. :9.0 Max. :5 2.6.2.4 Сортировка таблц Сортировка таблиц осуществляется с помощью функции order. # Сортировка таблиц users[ order( users$Age, decreasing = T), ] 2.6.2.5 Создание поднаборов таблиц Для создания поднабора данных в R существует функция subset, в которой вы может задать условия фильтрации по различным полям таблицы объединив несклько условий логическими И или ИЛИ, при этом следует использовать одиночные логические операторы (&amp;, |). # Выбираем поднабор состоящий из пользователей от 30 лет и старше users_after_30 &lt;- subset(x = users, Age &gt; 30, select = c(Id, Names)) # Выбираем пользователейв имени которых присутвует буква &quot;к&quot; и количество букв в имени более 5 users_i &lt;- subset(x = users, grepl(x = users$Names, pattern = &quot;к&quot;) &amp; nchar(as.character(users$Names)) &gt; 5, select = c(Id, Names)) 2.6.2.6 Объединение таблиц Для объединения таблиц служат следующие 3 функции: + rbind - Соединение таблиц по строкам + cbind - Соединение таблиц по столцам + merge - Соединение таблиц по ключу users_two &lt;- rbind(users_after_30, users_i) # объединения таблиц по строкам users_three &lt;- cbind(users_after_30 ,users_i) # объединение таблиц по столбцам # Объединение таблиц по ключу # Соединяем таблицу пользователей со справочником по id страны user_resul &lt;- merge(x = users, # левая таблица y = country_dicy, # правая таблица by.x = &quot;Country_id&quot;, # имя поля ключа в левой таблице by.y = &quot;id&quot;, # имя поля ключа в правой таблице all.x = TRUE) # тип соединения, в данном случае левое соединение Функция merge предназначена для соединения таблиц по ключам и принимает следующие аргументы: + x - левая таблица + y - правая таблица + by.x - ключи, название ключевых полей в левой таблице, если ключевых полей несколько их необзодимо передать в виде тектового вектора объединив их названия с помощью функции c. + by.y - ключи, название ключевых полей в правой таблице, если ключевых полей несколько их необзодимо передать в виде тектового вектора объединив их названия с помощью функции c. + all.x или all.y - аргументы которые управляют направлением соединения, allx = TRUE означает оставить все строки левой таблицы, т.е. левое соединение. 2.6.3 Списки (list) Объекты класса list могут являтся контейнерами для храннения других объектов, в том числе и других списков, как правило объекты класса list испоьзуются для хранения данныхимеющих сложную вложенную структуру, к примеру в виде списков удобно хранить данные прочитанные из JSON формата. 2.6.3.1 Создание списков my_list &lt;- list(user = list(id = 1, name = &quot;Alex&quot;, data = users[ users$Id == 1, ] )) my_list_2 &lt;- list(users, age, names, name_vector) 2.6.3.2 Обращение к элементам списка my_list$user$data$Names my_list_2[[4]] my_list_2[[4]][[2]] my_list_2[[4]][[&quot;company&quot;]] 2.6.4 Проверить класс объекта class(users) class(age) class(my_list) 2.7 Работа со строками на языке R 2.7.1 Базовые возможности для работы со строками в R В базовом R существует достаточно большой набор функций для работы со строками, ниже приведён пример манипуляции с текстовыми данными. # Конкатенация paste(&quot;Объелинить&quot;, &quot;несколько&quot;, &quot;строк&quot;) ## [1] &quot;Объелинить несколько строк&quot; paste0(&quot;Объелинить&quot;, &quot;несколько&quot;, &quot;строк&quot;) ## [1] &quot;Объелинитьнесколькострок&quot; paste(c(&quot;первый&quot;, &quot;текстовый&quot;, &quot;вектор&quot;), c(&quot;второй&quot;, &quot;вектор&quot;), collapse = &quot;-&quot;, sep = &quot;+&quot;) ## [1] &quot;первый+второй-текстовый+вектор-вектор+второй&quot; С помощью функций paste и paste0 можно объединять строкии склеивать текстовые векторы в кдиную строку, аргумент sep задаёт разделитель который будет добавлен между склеиваемыми частями, а аргумент collapse задаёт разделитель через который будут объедены результаты склеивания разных частей. Для извлечения части строки в R используется функция substr. text &lt;- c(&quot;Склеить&quot;, &quot;несколько&quot;, &quot;строк&quot;, &quot;в&quot;, &quot;одну&quot;) substr(text, start = 3, stop = 5) ## [1] &quot;леи&quot; &quot;ско&quot; &quot;рок&quot; &quot;&quot; &quot;ну&quot; Разбить строку через разделитель можно с помощью функции strsplit. my_string &lt;- &quot;Первая часть, вторая часть, третья часть&quot; strsplit(my_string, &quot;, &quot;) ## [[1]] ## [1] &quot;Первая часть&quot; &quot;вторая часть&quot; &quot;третья часть&quot; Примеры преобразования регистра строки. my_string &lt;- c(&quot;Разные РЕГИСТРЫ&quot;, &quot;ПрИМеР РеГисТРА&quot;) tolower(my_string) # перевод в верхний регистр toupper(my_string) # перевод в нижний регистр casefold(my_string, upper = TRUE) # перевод в верхний регистр casefold(my_string, upper = FALSE) # перевод в нижний регистр Работа с регулярными выражениями в R. # работа с регулярными выражениями grepl(x = text_with_spaces, pattern = &quot;^ &quot;, ignore.case = T) # проверить соответвует ли срока регулярному выражению gsub(pattern = &quot;^ | {2, }| $&quot;, replacement = &quot;&quot;, x = text_with_spaces) # замена части строки по регулярному выражению # получить подстроку соответвующую регулярному выражению m &lt;- regexpr(&quot;(.*о.*)&quot;, text) regmatches(x = text,m = m) 2.7.2 Работа со строками с помощью пакета stringr Базовые функции для работы со строками в R начительно различаются в стиле наименования как самих функций так и их аргументов, в связи с чеь замечательный пакет sringr, названия всех функций пакета начинаются с префикса str_, аргументы всех функций схожы. # преобразование строки str_c(text, c(&quot;раз&quot;, &quot;два&quot;, &quot;три&quot;), collapse = &quot;-&quot;, sep = &quot;+&quot;) # конкатенация строк str_replace_all(string = &quot;УбИрём одно слово&quot;, pattern = &quot;УбИрём&quot;, replacement = &quot;Уберём&quot;) # замена части строки str_to_lower(&quot;Перевод В Нижний Регистр&quot;) # перевод в нижний регистр str_to_upper(&quot;перевод в верхний регистр&quot;) # перевод в верхний регистр str_to_title(&quot;заглавная первая буква&quot;) # перевод в регистр заголовков str_remove_all(&quot;Уберём все пробелы&quot;, &quot; &quot;) # удаление символов из строки str_squish(&quot; Уберём лишние пробелы &quot;) # Удаление лишних пробелов str_split(&quot;Разобъём - строку - по - разделителю&quot;, &quot; - &quot;) # разбивка строки по разделителю str_pad(&quot;дополняем строку&quot;,side = &quot;both&quot;, width = 50, pad = &quot;$&quot;) # дополнение строки опредённым символов до нужного размера # извлечение части строки str_extract(pattern = &quot;(.*о.*)&quot;, string = text) # извлечение части строки по паттерну str_sub(&quot;Часть строки&quot;, start = 3, end = 7) # извлечние части строки по номеру символа word(&quot;Извлекаем слова по их номерам из предложения&quot;, 4, end = 7) # извлечение слова из предложения word(&quot;Извлекаем_слова_по_их_номерам_из_предложения&quot;, 4, end = 7, &quot;_&quot;) # извлечение слова из предложения разделённого _ # подсчёт символов str_length(&quot;Какая то большая строка&quot;) # посчитать количество символов str_count(string = &quot;посчитаем сколько раз встречается буква о&quot;, pattern = &quot;о&quot;) # считает количество входежний символа в строку # проверка строки str_detect(string = &quot; пробел&quot;, pattern = &quot;^ &quot;) # проверяет соответсвие строки регулярному выражению Так же пакет stringr дополнительно даёт возможность использовать объекты рабочего окружения и результаты работы функций в строках, т.е. конкатенировать созанные вами переменные или результат выполнения какой либо функции в строку, для этого в пакете есть две функции: str_glue и str_interp. str_glue - даёт возможность интерполировать внутрь строки значения из созданных в рабочем окружении объектов, имена объектов помещаются при этом в фигурные скобки. str_interp - используется для встраивания внутрь строки выражения, которое возвращается в результате рабоы каких либо функций языка R, для встраивания результата необходимо поставить знак долара и далее фигурных скобках написать выражение, результат которого вы хотите конкатенировать в строку. Примеры использования приведённых выше функций: # создаём переменные которые будем использовать в строках name &lt;- c(&quot;Alexey&quot;, &quot;Sergey&quot;) surname &lt;- c(&quot;Seleznev&quot;, &quot;Petrov&quot;) age &lt;- c(34, 38) city &lt;- c(&quot;Odessa&quot;, &quot;Moscow&quot;) # подстановка значений в строку из переменных stringr::str_glue(&quot;Hi, my name is {name} {surname}. I am {age} years old and i live in {city}.&quot;) ## Hi, my name is Alexey Seleznev. I am 34 years old and i live in Odessa. ## Hi, my name is Sergey Petrov. I am 38 years old and i live in Moscow. # подстановка результатов работы функций paste и mean в строку stringr::str_interp(&quot;Average age by ${paste(name, collapse = &#39; and &#39;)} is a ${mean(age)}&quot;) ## [1] &quot;Average age by Alexey and Sergey is a 36&quot; 2.8 Загрузка данных из csv, excel и json файлов в R 2.8.1 Загрузка данных из csv файлов Наиболее удобным и гибким способом загрузки данных в R из csv файлов является функция read.table, первый аргументом которой является путь к файлу, аргумент sep отвечает за то, какие разделители полей используются в csv файле, и аргумент header принимает логическое значение TRUE или FALSE, и с его помощью вы можете указать что первая строка в вашем csv файле содержит заголовки полей. Пример кода для загрузки данных из csv файла, все файлы находятся в папаке матриалы курса - модуль 1 - урок 7. # Переходим в работую директорию setwd(&quot;C:/r_for_marketing_course/Материалы курса/Модуль 1/Урок 7/&quot;) sales &lt;- read.table(&quot;sales.csv&quot;, sep = &quot;;&quot;, header = T) country &lt;- read.table(&quot;country.csv&quot;, sep = &quot;;&quot;, header = T) clients &lt;- read.table(&quot;clients.csv&quot;, sep = &quot;;&quot;, header = T) product &lt;- read.table(&quot;product.csv&quot;, sep = &quot;;&quot;, header = T) 2.8.2 Загрузка данных из Excel файлов Для работы с Excel файлами необходимо установить и подключить пакет readxl, для этого необходимо выполнить функции install.packages и library, далее с помощью функции read_excel можно прочитать данные из любого листа Excel книги. ## загрузка данных из Excel файлов install.packages(&quot;readxl&quot;) library(readxl) bad_format_data &lt;- read_excel( &quot;tidyr_example.xlsx&quot; , sheet = &quot;tidyr_example&quot;, col_names = T) 2.8.3 Загрузка данных из JSON файлов Для работы с JSON форматом необходимо загрузить и подключить пакет jsonlite. install.packages(&quot;jsonlite&quot;) library(jsonlite) data_from_json &lt;- read_json(&quot;dictionary.json&quot;) 2.9 Агрегирующие функции и арифметические операции в R Пример работы с наиболее часто используемыми агрегирующими функциями. # Агрегирующие функции sum(sales$quantity) # суммирование mean(sales$quantity) # среднее арифметическое median(sales$quantity) # медиана quantile(sales$quantity, probs = 0.25) # квантиль length(sales$quantity) # количество length(unique(sales$manager)) # количество уникальных Арифметические операции: # Арифметические операции 5 + 2 # сложение 5 - 2 # вычитание 5 * 2 # умножение 5 / 2 # деление 5 ** 2 # степень 5 %/% 2 # целочисленное деление 5 %% 2 # остаток от целочисленного деления 2.10 Манипуляция с данными, (группировка и агреция). 2.10.1 Пакет dplyr Пакет dplyr является наиболее популярным пакетом для работы с данными в R, все функции пакета представляют из себя глаголы, синтаксис пакета очень напонимает синтаксис SQL запросов. Основные команды для работы с данными в пакете dplyr select - выбор полей из data.frame filter - фильтрация данных arrange - сортировка данных group_by - группировка данных summarise - агрегация данных Соединение таблиц осуществляется с помощью функций семейства join: inner_join - возвращает строки общие для обеих таблиц соединения left_join - левое соединение, возвращает все строки из левой таблицы, и соответвующие по ключи строки из правой таблицы right_join - правое соединение, возвращает все строки из правой таблицы, и соответвующие по ключи строки из левой таблицы full_join- декартово произведение, возвращает все вараинты соединения каждой строки из левой таблицы с каждой сторокой из право таблицы Операция JOIN Фильтрующие соединения: semi_join - возвращает все строки из левой таблицы, для которых по ключу найдены соответвия в правой таблице anti_join - возвращает все строки из левой таблицы, для которых по ключу небыли найдены соответвия в правой таблице Конвеерный синтаксис В пакет dplyr из пакета magrittr был взаимствован конвеерный оператор %&gt;%, с помощью него можно избегать создание промежуточных объектов, данный оператор передаёт в качестве первого аргумента функции результат выпонения функции на прошлом шаге, если вам необходимо передать результат выполнения прошлого шага не в первый, а какой либо другой аргумент функции на следующем шаге то вы можете воспользоваться точкой, которая и будет хранить результат выполнения прошлого шага. Пример конвеерной записи преобразования данных library(dplyr) setwd(&quot;C:/r_for_marketing_course/Материалы курса/Модуль 1/Урок 7/&quot;) sales &lt;- read.table(&quot;sales.csv&quot;, sep = &quot;;&quot;, header = T) # конверный стиль записи sales %&gt;% group_by(manager) %&gt;% # группируем таблицу по полю manager summarise(count = n(), # считаем количество строк по каждому менеджеру total_quantity = sum(quantity), # считаем количество проданных едениц товара average_quantity = mean(quantity), # считаем среднее количество едениц товара в транзации products = length(unique(product_id))) %&gt;% # считаем какое к-во наименований товара продал менеджер arrange(-total_quantity) %&gt;% # сортирум таблицу по полю total_quantity по убыванию head(3) # оставляем 3 верхние строки Приведённый выше код делает следующе, передаёт в первый аргумент функции group_by, с помощью конвеерного оператора %&gt;% объкт sales и тем самым группирует дата фрейс sales по полю manager. Результат группировки, опять же с помощью конвеерного оператора %&gt;% передаётся в качестве первого аргумента функции summarise, далее к сгруппированным данным применяется ряд агрегаций, функции n() считает количество строк попавших в каждую группу, функция sum суммирует данные в каждой группе по полю quantity, функция mean считает среднее значение по полю quantity, а конструкция length(unique(product_id)) считает количество уникальных product_id в каждой группе. После агрегации мы через конвеерный оператор %&gt;% передаём полученный на прошлом шаге результат в качестве первого аргумента функции arrange, и производим сортиртировку по убыванию поля total_quantity, передаём отсортированный результат далее в функцию head через %&gt;% и оставляем первые три строки. В итоге мы получим следующий результат: manager count total_quantity average_quantity products Olga 25 124 4.960000 11 Andrey 31 114 3.677419 11 Alexey 31 111 3.580645 12 Пример работы с фильрующими соединениями # фильтрующие соединения anti_join(product, sales, by = c(&quot;id&quot; = &quot;product_id&quot;)) # товары по которым не было транзакций semi_join(product, sales, by = c(&quot;id&quot; = &quot;product_id&quot;)) # товары по которым были транзакции 2.10.2 Пакет data.table Пакет data.table предназначен для работы с большими массивами данных, по своему синтаксису он похож на работу с обычными data.frame, но в квадратных скобках мы указываем не только строки и столбцы которые необходимо выбрать, но и можем задавать группировку и агрегацию данных. Загрузка данных с помощью data.table Для загрузки данных из csv файлов в data.table есть функция fread, она принимает теже аргументы, что и стандартная функция read.table но работает в разы быстрее, и создаёт объекты класса data.table. Синтаксис пакета data.table Синтаксис data.table Обращение к полям таблиц, агрегация и группировка данных в data.table осуществляется внутри квадратных скобок, сначала мы указываем какие строки хотим выбрать, потом указываем агрегирующие операции и поля которые хотим в результате получить, и в третем блоке с помощью аргумента by или bykey мы указываем поля по которым хотим сгруппировать результат. Вместо конвеерных операций расмотренных в пакете dplyr, в data.table существуют цепочки, записываются они следующим образом: data_table_name[1ое звено][2ое звено][3ее звено][4ое звено][...] Таким образом каждое следующее звено работает с результатом полученным из прошлого звена. Пример работы с пакетом data.table С помощью синтаксиса data.table мы можем получить тот же резуьтат, что и при работе с dplyr: library(&quot;data.table&quot;) setwd(&quot;C:/r_for_marketing_course/Материалы курса/Модуль 1/Урок 7/&quot;) # загрузка данных sales_dt &lt;- fread(&quot;sales.csv&quot;) sales_dt[, .(count = .N, # считаем количество строк по каждому менеджеру total_quantity = sum(quantity), # считаем количество проданных едениц товара average_quantity = mean(quantity), # считаем среднее количество едениц товара в транзации products = length(unique(product_id))), # считаем какое к-во наименований товара продал менеджер by = manager][order(total_quantity, decreasing = TRUE)][1:3,] Приведённый выше код вернёт результат аналогичный тому, который был получен ранее при работе с пакетом dplyr. manager count total_quantity average_quantity products Olga 25 124 4.960000 11 Andrey 31 114 3.677419 11 Alexey 31 111 3.580645 12 2.10.3 Пакет sqldf sqldf является менее популярным пакетом по сравнению с dplyr и data.table, основным его назначением является возможность манипулировать с данными с помощью SQL синтаксиса. Пакет поддерживает 4 SQL диалекта: SQLite (по умолчанию), MySQL, PostgreSQL, H2. Для того, что бы установить нужный диалект необходимо поменять опцию sqldf.driver. options(sqldf.driver = &quot;SQLite&quot;) Для того, что бы получить с помощью пакета sqldf результат аналогичный тому, что мы ранее получили с помощью пакетов dplyr и data.table необходимо выполнить следующий код. library(sqldf) # повторяем агрегацию применяемую в примере с dplyr и data.table sqldf_exampl &lt;- sqldf(&quot;SELECT manager, COUNT(*) as count, SUM(quantity) as total_quantity, AVG(quantity) as average_quantity, COUNT(DISTINCT product_id) as products FROM sales GROUP by manager ORDER BY total_quantity DESC LIMIT 3&quot;) В результате его выполнения, мы получим уже знакомый результат агрегации данных. manager count total_quantity average_quantity products Olga 25 124 4.960000 11 Andrey 31 114 3.677419 11 Alexey 31 111 3.580645 12 2.10.4 Пакет tidyr Данный пакет предназначен для придания данным так называемого аккуратного вида, так такую концепцию данных называют Tidy data, заключается она в том, что наиболее удобно работать с данными приведёнными к такому виду, когда каждая строка таблицы соответствует одному наблюдения, а каждый столбец хранит информацию об одном свойстве наблдений. Задача: в материалах курса есть файл tidyr_example.xlsx, найти его можно в папке материале курса / модуль 1 / урок 7. Сам файл представляет из себя таблицу следующего вида: файл tidyr_example.xlsx Довольно часто коллеги предоставляют вам данные именно в таком виде,но работать с такими данными неудобно, т.к. существуют следующие ошибки. Поле country было сгруппировано в Excel, и при загрузке данных в R большая часть ячеек в этом поле не будут заполнены. Поле client_code содержит код клиента, который в свою очередь хранит информацию сразу о трёх его свойствах, о сегмента клиента, его номер, и класс клиента, в данном случае все три свойства хранятся в одном поле, что не соответвует концепции Tidy data. 4 столбца хранят информацию о количестве продаж в кокретном месяце, но месяц является отдельным свойством наблюдения, и название месяцаа должно храниться в отдельном столбце, и количество продаж в конкретном месяце так же необходимо хранить как отдельное свойство продажи. Пакет tidyr предоставляет набор функций с помощью которых можно исправить все перечисленные выше проблемы и привести данные к аккуратному виду. Функции в tidyr fill - заполнение пропущенных значений в поле, в нашем случае заполнение поля country separate - разделяет одно поле на несколько, в нашей задаче нам необходимо разбить поле client_code на 3 поля client_segment, client_id и client_class. unite - совершает операцию объеденения нескольких полей в одно, дейтсвие обратное функции separate. gather - функция преобразующая данные из широкого формата в длинный,в нашем случае мы будем с помощью неё преобразовывать поля June, July, Aug, Sept в два поля month, в котром будет хранится название месяца и sales_count, в котором будет хранится информация о количестве продаж. spread - функция преобразующая данные из длинного формата в широкий, операция обратнаяя той, которую осуществляет функция gather. Для решения приведённой задачи с помощью конвеерного стиля необходимо выполнить следующий код: library(tidyr) library(readxl) setwd(&quot;C:/r_for_marketing_course/Материалы курса/Модуль 1/Урок 7/&quot;) bad_format_data &lt;- read_excel( &quot;tidyr_example.xlsx&quot; , sheet = &quot;tidyr_example&quot;, col_names = T) good_data &lt;- bad_format_data %&gt;% fill(country) %&gt;% separate(col = client_code, into = c(&quot;client_segment&quot;, &quot;client_id&quot;, &quot;client_class&quot;), sep = &quot;_&quot;) %&gt;% gather(key = &quot;month&quot;, value = &quot;sales_count&quot;, June:Sept) В рузультате чего мы приведём наши данные к аккуратному виду, (верхние 20 строк результирующей табицы): country client_segment client_id client_class month sales_count UA c2с 1 a June 74 UA b2b 2 a June 45 UA c2с 3 c June 37 UA c2с 4 b June 87 UA c2с 5 a June 55 RU b2b 2 b June 66 RU c2с 4 a June 70 RU b2b 5 a June 62 KZ b2b 8 c June 57 KZ c2с 6 b June 51 KZ c2с 9 a June 43 KZ b2b 10 b June 62 KZ b2b 2 b June 44 KZ c2с 3 c June 60 KZ c2с 11 b June 48 KZ b2b 12 c June 62 UA c2с 1 a July 87 UA b2b 2 a July 58 UA c2с 3 c July 31 UA c2с 4 b July 65 2.11 Работа с датами и временем в R, пакет lubridate. 2.11.1 Базовые возможности по работе с датой и временем в R В R дата и время являются отдельным типом данных, базовые функции для работы с датами предоставляют следующие возможности. Sys.Date() # текущая дата Sys.Date() - 7 # дата которая была 7 дней назад Sys.time() # текущая дата и время Sys.timezone() # часовой пояс first_day_in_2018 &lt;- as.Date(&quot;2018-01-01&quot;) # преобразование текста в дату class(first_day_in_2018) # проверка того, является ли переменная датой # последовательность дат date_vector &lt;- seq.Date(from = first_day_in_2018, to = as.Date(&quot;2018-06-01&quot;), by = &quot;month&quot;) seq.Date(from = first_day_in_2018, to = as.Date(&quot;2018-06-01&quot;), by = &quot;week&quot;) seq.Date(from = first_day_in_2018, to = as.Date(&quot;2018-06-01&quot;), length.out = 10) 2.11.2 Пакет lubridate Довольно общирные возможности по работе с датой и временем предоставляет пакет пакет lubridate. library(lubridate) today() # текущая дата date() # текущая да now() # текущая дата и время start_time &lt;- now() 2.11.2.1 Преобразование строки в дату с помощью функций lubridate Для преобразования строки в дату в lubridate существует набор функций, все эти функции состоят из первых букв состовляющих даты, y - год, m - месяц и d - день. # преобразовать строку в дату ymd(&quot;20180715&quot;) # преобразум стоку формата ГГГГММДД в дату ymd(&quot;2018-07-15&quot;) # преобразум стоку формата ГГГГ-ММ-ДД в дату mdy(&quot;07152018&quot;) # преобразум стоку формата ММДДГГГГ в дату dmy(&quot;15.07.2018&quot;) # преобразум стоку формата ДД.ММ.ГГГГ в дату ymd_hms(&quot;2018-07-15 12:30:00 Europe/Helsinki&quot;) # преобразуем строку ГГГГ-ММ-ДД ЧЧ:ММ:СС в дату и время 2.11.2.2 Работа с часовыми поясами в lubridate. # часовые пояса my_time &lt;- now() OlsonNames(tzdir = NULL) # список всех часовых поясов with_tz(my_time, tzone = &quot;UTC&quot;) # преоразуем в временную метку в часовой пояс UTC with_tz(my_time, &quot;America/Chicago&quot;) # преоразуем в временную метку в часовой пояс America/Chicago 2.11.2.3 Извлечение отдельных компонентов даты с помощью функций пакета lubridate # получить день, месяц и год из даты today_date &lt;- today() day(today_date) # получить день из даты month(today_date) # получить месяц из даты year(today_date) # получить месяц из даты quarter(today_date) # получить номер квартала из даты qday(today_date) # получить номер дня в квартале yday(today_date) # получить номер дня в году # получить днь недели wday(today_date, label = TRUE, abbr = TRUE, week_start = 1) 2.11.2.4 Округление, и прочие арифметические операции с датами с помощью lubridate # округление дат round_date(today_date, unit = &quot;month&quot;) # округлить до ближайшего месяца round_date(today_date, unit = &quot;quarter&quot;) # округлить до ближайшего квартала floor_date(today_date, unit = &quot;month&quot;) # округлить вниз до ближайшего месяца ceiling_date(today_date, unit = &quot;month&quot;) # округлить вверх до ближайшего месяца ceiling_date(today_date, unit = &quot;quarter&quot;) # арифметичские операции с датами today() - months(6) # 6 месяцев назад от текущей даты # получить первый и последний прошлого квартала today() - qday(today()) # получаем конец прошлого квартала floor_date(today() - qday(today()), unit = &quot;quarter&quot;) # получаем начало прошлого квартала # получить первый и последний прошлого месяца floor_date(today() - day(today()), unit = &quot;month&quot;) today() - day(today()) 2.11.2.5 Операции над данными со временм в lubridate # Работа со временем в R # вычисление длительности end_time &lt;- now() difftime(end_time, start_time, units = &quot;secs&quot;) # в секундах difftime(end_time, start_time, units = &quot;mins&quot;) # в минутах end_time + hours(30) # прибавить 3 часа end_time + minutes(15) # прибавить 15 минут hour(end_time) # получить часы из времени minute(end_time) # получить минуты из времени second(end_time) # получить секунды из времени 2.12 Условные конструкции if, ifelse, switch в R Для работы с уловными конструкциями в R существует оператор if, функция ifelse и функция switch. Наиболее простой способ использования условий в R предоставляет функция ifelse, по синтаксису она идентична функции ЕСЛИ в Excel. vec_1 &lt;- runif(n = 30, min = 5, max = 50) # векторизированный оператор ifelse ifelse(vec_1 &gt; 25, &quot;Больше 25&quot;, &quot;Меньша 25&quot;) В случае если вам необходимо проверить более чем одно условие необхимо использовать конструкцию if - else. Синтаксис оператора if x &lt;- 10 # условная конструкция if if (x &lt; 25) { print(&quot;x меньше 25&quot;) } else if (x &lt;= 40) { print(&quot;x больше 25 но меньше 40&quot;) } else { print(&quot;x больше 40&quot;) } Таким образом можно добавлять люое количество условий с помощью оператров else if, далее добавляется обычный оператор else Функция switch напоминает привычный для SQL оператор CASE, она принимает все варианты возможных взодящих параметров, и для кадого входящего параметра определяет значение которое необходимо вернуть. employ_name &lt;- &quot;Alexey&quot; # переключатель, аналог case switch (employ_name, Alexey = 3, Sergey = 1.5, Denis = 2, Nikolay = 4, 0) 2.13 Циклы for и while 2.13.1 Цикл for Цикл for представляет из классический цикл со счётчиком. Простейший пример пример цикла for: # Цикл for employ_name &lt;- c(&quot;Alexey&quot;, &quot;Sergey&quot;, &quot;Nikolay&quot;) for (name in employ_name) { print(paste(&quot;Hello&quot;, name)) } for (i in 1:length(employ_name)) { print(paste(&quot;Hello&quot;, employ_name[i])) } В данном случае цикл будет состоять из трёх итераций, на каждой итерации в переменную-счётчик name будет подставлен один элемент вектора employ_name. Задача: В материалах курса, в папке модуль 1 - урок 9, есть 7 csv файлов одинаковой структуры, довольно часто встречается задача когда необходимо объеденить данные из файлов одинаковой структуры в один. Нам необходимо реализовать процесс склейки файлов в одну таблицу в R. # загрузка данных из множества файлов одинаковой структуры setwd( &quot;C:/r_for_marketing_course/Материалы курса/Модуль 1/Урок 9&quot;) # переходим в рабочую директорию library(dplyr) # подключаем пакет dplyr files &lt;- dir() # получаем список файлов из рабочей директории load_files &lt;- files[ grepl(&quot;^data_from&quot;, files) ] # оставляем список файлов который начинается на load_data load_data &lt;- list() # создаём объек класса list в который будет загружать файлы for (f in load_files) { load_data &lt;- c(load_data, # по очереди загружаем каждый файл и присоединяем к объекту load_data list(read.table(f, sep = &quot;;&quot;, header = T))) } data &lt;- bind_rows(load_data) # преобразуем загруженные файлы в data.frame C помощью команы setwd мы делаем нужную папку нашим рабочим каталогом. Далее функция dir возвращает вектор, состоящий из имён всех файлов которые находятс яв рабочем каталоге. Т.к. помимо нужных нам файлов в каталоге присутвуют и другие, то с помощью grepl и регулярного выражения ^data_from мы оставляет только те файлы, имена которых начинаются на data_from, и созраняем их в вектор load_files. Создаём пустой список load_data, в который по очереди будем добавлять загруженные данные. С помощью цикла for мы перебираем по очереди все имена файлов из вектора load_files, и подставляем их в функцию read.table, в данном случае переменной-счётчиком у нас является объект f, заданный в круглых скобках после объявления цикла for. После загрузки всех файлов мы объединяем их в одну таблицу с помощью функции bind_rows из пакета dplyr. 2.13.2 Цикл while Цикл while используется в том случае если до запуска цикла мы не знаем точное количество итераций, он будет выполняться до тех пор пока будет возвращать истину заданное после его объявление логическое выражение. # Цикл whie x &lt;- 0 while ( x &lt; 7 ) { print(paste(&quot;x равен&quot;, x)) x &lt;- x + 1 } В данном пример цикл будет выполняться до тех пор пока переменная x будет меньше 7, при этом на кажой итерации цикла мы увеличиваем значение переменной x на единицу с помощью конструкции x &lt;- x + 1. Ещё рлин пример работы с циклом while. input &lt;- &quot;&quot; while (input != &quot;stop&quot;) { input &lt;- readline(&quot;Введите текст: &quot;) print(paste0(&quot;Ваш текст: &quot;, input)) } Этот цикл проси ввести значение с клавиатуры с помощью функции readline, и итерации будут продолжаться до тех пор, пока вы не введёте слово stop. Возможно вы захоьите добавить дополнительную проверку, и выйти из цикла while даже если основное условие по прежнему возвращает истину, допустим вы хотите ограничить количество итераций, для этого в R существует оператор break. input &lt;- &quot;&quot; n &lt;- 0 while (input != &quot;stop&quot;) { input &lt;- readline(&quot;Введите текст: &quot;) print(paste0(&quot;Ваш текст: &quot;, input)) n &lt;- n + 1 if (n &gt; 3) { print(&quot;Вы вводили текст более трёх раз, цикл окончен&quot;) break } } Так же и как в прошлом примере R будет просить ввести текст, цикл будет итерироваться до тез пор пока вы не введёте слово stop, но мы парралельно ввеи счётчик n, который увеличиваем на 1 с каждой новой итерацией n &lt;- n + 1, далее в теле цикла с помощью условной конструкции if проверяется условие n &gt; 3, если n более трёх мы выводим сообщение Вы вводили текст более трёх раз, цикл окончен, и выходим из цикла с помощью оператора break. 2.14 Разработка собственных функций в языке R Создание собственных функций осузествляется с помощью оператора function. Функция, так же как и всё, что мы создаём в рабочем окружении, является объектом, поэтому создаётся функция так же, мы указываем имя фунции и пишем знак присвоения &lt;-. Далее пишем оператор function, в скобкаъ перечисляем все аргументы, осткрываем фигурную скобку после чего пишем тело функции, результат выполнения функции мы возвращаем передав его внутри тела функции в return. # простая функция my_fun_sum &lt;- function(x, y, z) { result &lt;- (x + y) * z return(result) } my_fun_sum(10, 15, 2) # функция с переключателем agr &lt;- function (x, type) { switch(type, mean = mean(x), median = median(x), sum = sum(x), quantiles = quantile(x, probs = c(0.25, 0.5, 0.75))) } agr(c(5, 17, 32, 15), type = &quot;mean&quot;) agr(c(5, 17, 32, 15), type = &quot;quantiles&quot;) # функция для загрузки файлов file_loader &lt;- function(prefix, ...) { # получаем список файлов из рабочей директории files &lt;- dir() # оставляем список файлов который начинается на load_data load_files &lt;- files[ grepl(prefix, files) ] # создаём объек класса list в который будет загружать файлы load_data &lt;- list() # циклом обрабатываем каждый файл for (f in load_files) { load_data &lt;- c(load_data, # по очереди загружаем каждый файл и присоединяем к объекту load_data list(read.table(f, ...))) } data &lt;- bind_rows(load_data) # преобразуем загруженные файлы в data.frame # возвращаем полученный результат return(data) } my_files &lt;- file_loader(prefix = &quot;^data_from&quot;, sep = &quot;;&quot;, header = TRUE) В примере выше показаны варианты разработки как самой элементарной пользовательской функции которая просто производит арифметические операции над треммя введёными аргументами, так и более сложная которая выполняет все действия для загрузки и объединения данных из множества csv файлов, которые мы рассматривали ранее изучая цикл for. 2.15 Обработка ошибок в R, функция try Достаточной важной частью разработки какого либо скрипта является обработка ошибок, давайте рассмотрим пример с ошибкой. возникающей в работе цикла. test_error_list &lt;- list(5, 12, 8, &quot;u&quot;, 3, 7, 9) for ( i in 1:length(test_error_list)) { print(paste0(&quot;i is &quot;, test_error_list[[i]])) print(test_error_list[[i]] * 12) } ## [1] &quot;i is 5&quot; ## [1] 60 ## [1] &quot;i is 12&quot; ## [1] 144 ## [1] &quot;i is 8&quot; ## [1] 96 ## [1] &quot;i is u&quot; ## Error in test_error_list[[i]] * 12: нечисловой аргумент для бинарного оператора Цикл, по очереди должен умножить каждой элемент списка test_error_list на 12, в начале тела цикла с помощью команды print мы выводим сообщение о том, какое значение имеет текущий, обратаваесый элемент. Цикл успешно умножил на 12 первые три элемента списка test_error_list, но 4ый элемент является текстовым, а R не умеет производить арифметические операции над текстом, возвращает ошибку, и цикл аварийно прекращает работу до того как он обработал все аргументы. Но мы с помощью функции try можем предусмотреть вариант возникновения ошибки при умножении следующим образом. test_error_list &lt;- list(5, 12, 8, &quot;u&quot;, 3, 7, 9) # обработка ошибок for ( i in 1:length(test_error_list)) { print(paste0(&quot;i is &quot;, test_error_list[[i]])) check_result &lt;- try (test_error_list[[i]] * 12, silent = TRUE) if (class(check_result) == &quot;try-error&quot;) { print(paste(&quot;error: &quot;, as.character(attr(check_result, &quot;condition&quot;)))) next } else { print(check_result) } } ## [1] &quot;i is 5&quot; ## [1] 60 ## [1] &quot;i is 12&quot; ## [1] 144 ## [1] &quot;i is 8&quot; ## [1] 96 ## [1] &quot;i is u&quot; ## [1] &quot;error: Error in test_error_list[[i]] * 12: нечисловой аргумент для бинарного оператора\\n&quot; ## [1] &quot;i is 3&quot; ## [1] 36 ## [1] &quot;i is 7&quot; ## [1] 84 ## [1] &quot;i is 9&quot; ## [1] 108 В скрипте выше, мы завернули вычисление test_error_list[[i]] * 12 в функцию try, которая не смотря на то, что в ходе цикла возникла ошибка продолжает его работу, но объект который она вернёт будет иметь класс try-error, для проверки корретно ли отработало вычисление мы добавили условную конструкцию if (class(check_result) == &quot;try-error&quot;), и в случае если умножение вернуло ошибку мы выводим сообщение, и переходим на следующую итерацию цикла с помощью команды next. 2.16 Рекомендации по оформлению кода Названия всех объектов должны быть понятными и осмысленными. Необходимо придерживаться единого стиля в именовании функций и их аргументов: snake_case, lowerCamelCase, UpperCamelCase, period.separated. Используйте в качестве знака присвоения -&gt; а не знак равенства, который в R принято использовать только в качестве знака присвоения для аргумнтов функций. Пробелы ставяться до и после математических символов, операторов присвоения в том числе операторов присвоения аргументов, логических операторов. Пробелы ставяться после запятых и управляющих конструкций if, for, while. Если функция имее большое количество аргументов для улучшение читаемости кода переносите каждый агрумент на новую строку, так же улучшит восприятие кода выравнив по строкам знаки присвоения значений аргументам добавив между именем аргумента и знаком = дополнительные пробелы, такой же приём можно использовать если в начале скрипта вы объявляете большое количество переменных. Во всех своих скриптах лучше придерживаться единой структуры кода, например я использую такой подход: 6.1. Подключение библиотек library 6.2. Переход в рабочую директорию setwd 6.3. Описание всех пользовательских функций используеых в скрипте function 6.4. Подключение к базам данных dbConnect 6.5. Аутентификация в API 6.6. Основная часть кода 6.7. Закрываем соедения с базами данных dbDisconnect. Если в одном скрипте используюстся функции из множества различных пакетов явно указывайте к какому паету принадлежик каждая функция package_name::function_name(). Комментируйте код, это улучшить навигцию по коду при работе в RStudio, и значительно упростить понимание кода в последствии. R не требует обязательного указания имён аргументов функций, но я рекомендую всегда явно описывать их имена если вы используете в функции более одно, явного и обязательного аргумента. "],
["intro.html", "3 Introduction", " 3 Introduction You can label chapter and section titles using {#label} after them, e.g., we can reference Chapter 3. If you do not manually label them, there will be automatic labels anyway, e.g., Chapter 5. Figures and tables with captions will be placed in figure and table environments, respectively. par(mar = c(4, 4, .1, .1)) plot(pressure, type = &#39;b&#39;, pch = 19) Figure 3.1: Here is a nice figure! Reference a figure by its code chunk label with the fig: prefix, e.g., see Figure 3.1. Similarly, you can reference tables generated from knitr::kable(), e.g., see Table 3.1. knitr::kable( head(iris, 20), caption = &#39;Here is a nice table!&#39;, booktabs = TRUE ) Table 3.1: Here is a nice table! Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa 4.6 3.4 1.4 0.3 setosa 5.0 3.4 1.5 0.2 setosa 4.4 2.9 1.4 0.2 setosa 4.9 3.1 1.5 0.1 setosa 5.4 3.7 1.5 0.2 setosa 4.8 3.4 1.6 0.2 setosa 4.8 3.0 1.4 0.1 setosa 4.3 3.0 1.1 0.1 setosa 5.8 4.0 1.2 0.2 setosa 5.7 4.4 1.5 0.4 setosa 5.4 3.9 1.3 0.4 setosa 5.1 3.5 1.4 0.3 setosa 5.7 3.8 1.7 0.3 setosa 5.1 3.8 1.5 0.3 setosa You can write citations, too. For example, we are using the bookdown package (Xie 2018) in this sample book, which was built on top of R Markdown and knitr (Xie 2015). References "],
["literature.html", "4 Literature", " 4 Literature Here is a review of existing methods. "],
["methods.html", "5 Methods", " 5 Methods We describe our methods in this chapter. "],
["applications.html", "6 Applications 6.1 Example one 6.2 Example two", " 6 Applications Some significant applications are demonstrated in this chapter. 6.1 Example one 6.2 Example two "],
["final-words.html", "7 Final Words", " 7 Final Words We have finished a nice book. "],
["references.html", "References", " References "]
]
